<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mira Maikel Sin Manos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #f7f7f7;
            color: #535353;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 300px;
            border-bottom: 2px solid #535353;
            overflow: hidden;
            background-color: #f7f7f7;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .message {
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
            background-color: rgba(247, 247, 247, 0.9);
            padding: 15px 20px;
            border: 2px solid #535353;
        }

        .sub-message {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 8px;
        }

        #score {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
        }

        #high-score {
            position: absolute;
            top: 10px;
            left: 20px;
            font-size: 14px;
            opacity: 0.6;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 600px) {
            .message {
                font-size: 18px;
            }

            .sub-message {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score">00000</div>
        <div id="high-score">HI 00000</div>

        <div id="ui-layer">
            <div id="start-message" class="message">
                MIRA MAIKEL SIN MANOS
                <div class="sub-message" id="input-instruction">Presiona ESPACIO para saltar</div>
            </div>
            <div id="game-over-message" class="message hidden">
                GAME OVER
                <div class="sub-message">Presiona ESPACIO para reiniciar</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURACIÓN ====================
        const CONFIG = {
            GRAVITY: 0.4,
            JUMP_VELOCITY: -10,
            GROUND_HEIGHT: 10,
            INITIAL_SPEED: 3.5,
            SPEED_INCREMENT: 0.00015,  // Incremento mucho más lento
            MAX_SPEED: 7.5,  // Tope más razonable
            OBSTACLE_BASE_MIN_DISTANCE: 300,  // Distancia mínima base
            OBSTACLE_BASE_MAX_DISTANCE: 550,  // Distancia máxima base
            CLOUD_SPAWN_DISTANCE: 300
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const startMsg = document.getElementById('start-message');
        const gameOverMsg = document.getElementById('game-over-message');
        const inputInstruction = document.getElementById('input-instruction');

        // ==================== GAME STATE ====================
        let gameSpeed = CONFIG.INITIAL_SPEED;
        let score = 0;
        let lastMilestone = 0;  // Para trackear hitos de 100 puntos
        let highScore = parseInt(localStorage.getItem('miraMaikelHighScore')) || 0;
        let isPlaying = false;
        let isGameOver = false;
        let animationId = null;
        let lastTime = 0;
        let distanceTraveled = 0;
        let nextObstacleDistance = 0;
        let nextCloudDistance = 0;
        let flashScore = false;  // Para efecto visual de puntuación

        // Mobile Detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            inputInstruction.innerText = "Toca la pantalla para saltar";
        }

        // Update High Score Display
        highScoreEl.innerText = `HI ${highScore.toString().padStart(5, '0')}`;

        // ==================== CANVAS RESIZE ====================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;

            ctx.scale(dpr, dpr);

            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ==================== PLAYER CLASS ====================
        class Player {
            constructor() {
                this.width = 44;
                this.height = 47;
                this.x = 50;
                this.y = 0;
                this.velocityY = 0;
                this.isJumping = false;
                this.frameIndex = 0;
                this.frameTimer = 0;
                this.frameInterval = 100; // milliseconds
            }

            get groundY() {
                return canvas.clientHeight - CONFIG.GROUND_HEIGHT - this.height;
            }

            jump() {
                if (!this.isJumping) {
                    this.velocityY = CONFIG.JUMP_VELOCITY;
                    this.isJumping = true;
                }
            }

            update(deltaTime) {
                // Apply gravity
                this.velocityY += CONFIG.GRAVITY;
                this.y += this.velocityY;

                // Ground collision
                if (this.y >= this.groundY) {
                    this.y = this.groundY;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Animation frame
                if (!this.isJumping) {
                    this.frameTimer += deltaTime;
                    if (this.frameTimer >= this.frameInterval) {
                        this.frameTimer = 0;
                        this.frameIndex = (this.frameIndex + 1) % 2;
                    }
                } else {
                    this.frameIndex = 0;
                }
            }

            draw() {
                const drawX = this.x;
                const drawY = this.y;
                const drawWidth = this.width;
                const drawHeight = this.height;

                ctx.fillStyle = '#535353';

                // Body
                ctx.fillRect(drawX + 6, drawY, drawWidth - 12, drawHeight - 10);

                // Head
                ctx.fillRect(drawX + 10, drawY - 6, drawWidth - 20, 10);

                // Eye
                ctx.fillStyle = '#f7f7f7';
                ctx.fillRect(drawX + 26, drawY - 2, 6, 4);

                // Legs (animated)
                ctx.fillStyle = '#535353';
                if (this.isJumping) {
                    // Both legs together when jumping
                    ctx.fillRect(drawX + 12, drawY + drawHeight - 10, 8, 10);
                    ctx.fillRect(drawX + 24, drawY + drawHeight - 10, 8, 10);
                } else {
                    // Running animation
                    if (this.frameIndex === 0) {
                        ctx.fillRect(drawX + 12, drawY + drawHeight - 10, 8, 10);
                        ctx.fillRect(drawX + 24, drawY + drawHeight - 7, 8, 7);
                    } else {
                        ctx.fillRect(drawX + 12, drawY + drawHeight - 7, 8, 7);
                        ctx.fillRect(drawX + 24, drawY + drawHeight - 10, 8, 10);
                    }
                }

                // Tail
                ctx.fillRect(drawX, drawY + 8, 8, 6);
            }

            getHitbox() {
                return {
                    x: this.x + 6,
                    y: this.y,
                    width: this.width - 12,
                    height: this.height - 3
                };
            }
        }

        // ==================== OBSTACLE CLASS ====================
        class Obstacle {
            constructor() {
                const types = [
                    { width: 20, height: 40 },   // Cactus delgado y alto
                    { width: 25, height: 45 },   // Cactus mediano
                    { width: 30, height: 35 },   // Cactus ancho y bajo
                    { width: 18, height: 50 },   // Cactus muy alto
                    { width: 35, height: 30 }    // Cactus muy ancho
                ];

                const type = types[Math.floor(Math.random() * types.length)];
                this.width = type.width;
                this.height = type.height;
                this.x = canvas.clientWidth;
                this.y = canvas.clientHeight - CONFIG.GROUND_HEIGHT - this.height;
                this.markedForDeletion = false;
            }

            update(deltaTime) {
                this.x -= gameSpeed;

                if (this.x + this.width < 0) {
                    this.markedForDeletion = true;
                }
            }

            draw() {
                ctx.fillStyle = '#535353';

                // Main body
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Add some spikes for cactus effect
                const spikeCount = Math.floor(this.width / 12) + 1;
                for (let i = 0; i < spikeCount; i++) {
                    const spikeX = this.x + (i * (this.width / spikeCount)) + 3;
                    const spikeY = this.y + 10 + (i % 2) * 10;
                    if (spikeY < this.y + this.height - 10) {
                        ctx.fillRect(spikeX, spikeY, 4, 10);
                    }
                }
            }

            getHitbox() {
                return {
                    x: this.x + 3,
                    y: this.y + 3,
                    width: this.width - 6,
                    height: this.height - 3
                };
            }
        }

        // ==================== CLOUD CLASS ====================
        class Cloud {
            constructor() {
                this.width = 46;
                this.height = 14;
                this.x = canvas.clientWidth;
                this.y = 20 + Math.random() * 80;
                this.markedForDeletion = false;
            }

            update(deltaTime) {
                this.x -= gameSpeed * 0.3; // Clouds move slower

                if (this.x + this.width < 0) {
                    this.markedForDeletion = true;
                }
            }

            draw() {
                ctx.fillStyle = '#535353';
                ctx.globalAlpha = 0.3;

                // Simple cloud shape
                ctx.fillRect(this.x, this.y + 4, 30, 8);
                ctx.fillRect(this.x + 8, this.y, 14, 14);
                ctx.fillRect(this.x + 20, this.y + 2, 18, 10);

                ctx.globalAlpha = 1.0;
            }
        }

        // ==================== GAME OBJECTS ====================
        let player = new Player();
        let obstacles = [];
        let clouds = [];

        // ==================== COLLISION DETECTION ====================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }

        function checkCollisions() {
            const playerHitbox = player.getHitbox();

            for (let obstacle of obstacles) {
                const obstacleHitbox = obstacle.getHitbox();
                if (checkCollision(playerHitbox, obstacleHitbox)) {
                    return true;
                }
            }
            return false;
        }

        // ==================== GAME FUNCTIONS ====================
        function getMinObstacleDistance() {
            // Calcula el tiempo que el jugador está en el aire
            const jumpDuration = (Math.abs(CONFIG.JUMP_VELOCITY) * 2) / CONFIG.GRAVITY;

            // Calcula la distancia que recorre durante un salto a la velocidad actual
            const jumpDistance = gameSpeed * jumpDuration;

            // Añade un margen de seguridad del 40% y suma la distancia base
            const safeDistance = jumpDistance * 1.4 + CONFIG.OBSTACLE_BASE_MIN_DISTANCE;

            return safeDistance;
        }

        function spawnObstacle() {
            obstacles.push(new Obstacle());

            const minDistance = getMinObstacleDistance();
            const randomExtra = Math.random() * (CONFIG.OBSTACLE_BASE_MAX_DISTANCE - CONFIG.OBSTACLE_BASE_MIN_DISTANCE);

            nextObstacleDistance = distanceTraveled + minDistance + randomExtra;
        }

        function spawnCloud() {
            clouds.push(new Cloud());
            nextCloudDistance = distanceTraveled + CONFIG.CLOUD_SPAWN_DISTANCE + Math.random() * 200;
        }

        function resetGame() {
            player = new Player();
            player.y = player.groundY;
            obstacles = [];
            clouds = [];
            score = 0;
            lastMilestone = 0;
            flashScore = false;
            gameSpeed = CONFIG.INITIAL_SPEED;
            distanceTraveled = 0;
            nextObstacleDistance = 400; // Primer obstáculo aparece después de un tiempo prudente
            nextCloudDistance = 100;
            isGameOver = false;
            isPlaying = true;
            lastTime = performance.now();

            scoreEl.innerText = "00000";
            scoreEl.style.opacity = '1';
            startMsg.classList.add('hidden');
            gameOverMsg.classList.add('hidden');

            resizeCanvas();
            animationId = requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            isPlaying = false;
            isGameOver = true;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            gameOverMsg.classList.remove('hidden');

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('miraMaikelHighScore', highScore.toString());
                highScoreEl.innerText = `HI ${highScore.toString().padStart(5, '0')}`;
            }
        }

        // ==================== GAME LOOP ====================
        function gameLoop(currentTime) {
            if (!isPlaying) return;

            // Calculate delta time in milliseconds
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            // Update game speed
            if (gameSpeed < CONFIG.MAX_SPEED) {
                gameSpeed += CONFIG.SPEED_INCREMENT * deltaTime;
            }

            // Update distance traveled
            distanceTraveled += gameSpeed;

            // Update score (increases with distance)
            const newScore = Math.floor(distanceTraveled / 10);

            // Check for milestone (cada 100 puntos)
            if (Math.floor(newScore / 100) > Math.floor(lastMilestone / 100)) {
                flashScore = true;
                setTimeout(() => { flashScore = false; }, 200);
            }

            score = newScore;
            lastMilestone = score;

            // Update score display with flash effect
            if (flashScore) {
                scoreEl.style.opacity = '0.3';
            } else {
                scoreEl.style.opacity = '1';
            }
            scoreEl.innerText = score.toString().padStart(5, '0');

            // Spawn obstacles
            if (distanceTraveled >= nextObstacleDistance) {
                spawnObstacle();
            }

            // Spawn clouds
            if (distanceTraveled >= nextCloudDistance) {
                spawnCloud();
            }

            // Update and draw clouds
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].update(deltaTime);
                clouds[i].draw();

                if (clouds[i].markedForDeletion) {
                    clouds.splice(i, 1);
                }
            }

            // Update player
            player.update(deltaTime);

            // Update and draw obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update(deltaTime);
                obstacles[i].draw();

                if (obstacles[i].markedForDeletion) {
                    obstacles.splice(i, 1);
                }
            }

            // Draw player
            player.draw();

            // Draw ground line
            ctx.beginPath();
            ctx.moveTo(0, canvas.clientHeight - CONFIG.GROUND_HEIGHT);
            ctx.lineTo(canvas.clientWidth, canvas.clientHeight - CONFIG.GROUND_HEIGHT);
            ctx.strokeStyle = '#535353';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Check collisions
            if (checkCollisions()) {
                gameOver();
                return;
            }

            // Continue loop
            animationId = requestAnimationFrame(gameLoop);
        }

        // ==================== INPUT HANDLING ====================
        function handleInput(e) {
            const isJumpKey = e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW';
            const isClick = e.type === 'touchstart' || e.type === 'mousedown';

            if (isJumpKey || isClick) {
                if (isJumpKey) {
                    e.preventDefault();
                }

                if (isGameOver || !isPlaying) {
                    resetGame();
                } else {
                    player.jump();
                }
            }
        }

        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });
        window.addEventListener('mousedown', handleInput);

        // Prevent space from scrolling
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target === document.body) {
                e.preventDefault();
            }
        });

        // ==================== INITIAL SETUP ====================
        resizeCanvas();
        player.y = player.groundY;
    </script>
</body>

</html>